datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/**
 * roles
 */
enum UserRole {
  user
  admin
}

/**
 * 주문 상태
 */
enum OrderStatus {
  AWAITING_DEPOSIT
  DEPOSIT_CONFIRMED
  SHIPPED
  DELIVERED
  CANCELED
}

/**
 * 반품 상태
 */
enum ReturnStatus {
  REQUESTED
  APPROVED
  REJECTED
  REFUNDED
}

/**
 * 사용자
 * - refresh token은 운영에서는 별도 Session 테이블로 관리 추천(여긴 단순화)
 */
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  role      UserRole @default(user)
  createdAt DateTime @default(now())

  refreshTokenHash String?

  orders  Order[]
  asks    Ask[]
  replies AskReply[]
}

/**
 * 카테고리 (slug 기반)
 */
model Category {
  id   Int    @id @default(autoincrement())
  slug String @unique // outer/top/bottom/acc/for-artist/look ...
  name String

  @@index([slug])
}

/**
 * 상품
 * - categorySlug는 slug로 바로 필터링하기 위해 유지
 */
model Product {
  id           Int     @id @default(autoincrement())
  categorySlug String
  name         String
  price        Int? // look은 내려줘도 프론트 미노출
  description  String?

  sizeGuideText    String?
  productInfoText  String?
  sizeGuideMdUrl   String?
  productInfoMdUrl String?
  lookMdUrl        String?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  images   ProductImage[]
  options  ProductOption[]
  variants ProductVariant[]

  @@index([categorySlug, createdAt])
}

/**
 * 상품 이미지
 */
model ProductImage {
  id        Int    @id @default(autoincrement())
  productId Int
  url       String
  sortOrder Int    @default(0)

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId, sortOrder])
}

/**
 * 옵션(표시용)
 * - size/color 선택지 자체
 * - 재고는 여기 두지 않고 Variant에서 관리
 */
model ProductOption {
  id            Int              @id @default(autoincrement())
  productId     Int
  groupKey      String // "size" | "color"
  label         String? // "SIZE" | "COLOR"
  value         String // "M", "L", "black", "white" ...
  sku           String?
  priceDelta    Int?
  variantSizes  ProductVariant[] @relation("VariantSizeOption")
  variantColors ProductVariant[] @relation("VariantColorOption")

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, groupKey, value]) // 같은 상품 내 중복 방지(원하면 제거 가능)
  @@index([productId, groupKey])
}

/**
 * Variant(조합 재고)
 * - sizeOptionId + colorOptionId 조합 단위 재고
 * - 옵션이 하나만 있는 상품이면 다른 한쪽은 null 허용
 */
model ProductVariant {
  id        Int @id @default(autoincrement())
  productId Int

  sizeOptionId  Int?
  colorOptionId Int?

  stock      Int     @default(0)
  sku        String?
  priceDelta Int?

  product     Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  sizeOption  ProductOption? @relation("VariantSizeOption", fields: [sizeOptionId], references: [id])
  colorOption ProductOption? @relation("VariantColorOption", fields: [colorOptionId], references: [id])

  orderItems OrderItem[]

  @@unique([productId, sizeOptionId, colorOptionId]) // 같은 조합 중복 방지
  @@index([productId])
}

/**
 * 주문
 * - 금액/만료시간은 서버가 결정
 * - receiver.address 구조를 테이블 컬럼으로 펼침
 */
model Order {
  id          String      @id // 서버에서 "O1"처럼 만들 수도 있고 uuid도 가능
  userId      Int
  status      OrderStatus @default(AWAITING_DEPOSIT)
  createdAt   DateTime    @default(now())
  expiresAt   DateTime
  shippedAt   DateTime?
  deliveredAt DateTime?
  canceledAt  DateTime?

  receiverName  String
  receiverPhone String
  receiverEmail String?
  zip           String
  address1      String
  address2      String
  memo          String?

  paymentMethod String // "BANK_TRANSFER"
  depositor     String?

  carrier    String?
  trackingNo String?

  grandTotal Int

  user       User        @relation(fields: [userId], references: [id])
  items      OrderItem[]
  return     Return?
  refundLogs RefundLog[]

  @@index([userId, createdAt])
  @@index([status, expiresAt])
}

/**
 * 주문 아이템
 * - VariantId로 어떤 조합을 샀는지 고정
 * - 스냅샷을 남겨야 상품명/가격이 바뀌어도 주문 내역이 안정적
 */
model OrderItem {
  id        Int    @id @default(autoincrement())
  orderId   String
  productId Int
  variantId Int? // look 상품 같은 옵션 없는 경우 null 가능(정책에 따라)
  qty       Int

  price         Int // 주문 당시 단가 스냅샷
  name          String // 주문 당시 이름 스냅샷
  thumbnailUrl  String?
  optionSummary String?

  order   Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  variant ProductVariant? @relation(fields: [variantId], references: [id])

  @@index([orderId])
}

/**
 * 반품
 * - 주문당 활성 반품 1개(= orderId unique)
 */
model Return {
  id        Int          @id @default(autoincrement())
  orderId   String       @unique
  status    ReturnStatus @default(REQUESTED)
  reason    String?
  memo      String?
  createdAt DateTime     @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

/**
 * 환불 로그
 */
model RefundLog {
  id        Int      @id @default(autoincrement())
  orderId   String
  amount    Int
  memo      String
  createdAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
}

/**
 * 시스템 정책
 * - key: returns, bankAccount, shipping
 */
model SystemPolicy {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

/**
 * 공지
 */
model Notice {
  id        String   @id
  title     String
  body      String
  createdAt DateTime @default(now())
}

/**
 * QnA(Ask)
 */
model Ask {
  id        String   @id
  userId    Int
  title     String
  body      String
  status    String   @default("waiting") // waiting|answered
  createdAt DateTime @default(now())

  deletedAt DateTime?

  user    User       @relation(fields: [userId], references: [id])
  replies AskReply[]
}

model AskReply {
  id        String   @id
  askId     String
  userId    Int?
  body      String
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())

  ask  Ask   @relation(fields: [askId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id])
}
